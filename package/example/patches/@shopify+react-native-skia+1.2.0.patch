diff --git a/node_modules/@shopify/react-native-skia/cpp/api/JsiPlatformBuffer.h b/node_modules/@shopify/react-native-skia/cpp/api/JsiPlatformBuffer.h
index b2bb75b..9a8d031 100644
--- a/node_modules/@shopify/react-native-skia/cpp/api/JsiPlatformBuffer.h
+++ b/node_modules/@shopify/react-native-skia/cpp/api/JsiPlatformBuffer.h
@@ -21,11 +21,11 @@ public:
     auto image = JsiSkImage::fromValue(runtime, arguments[0]);
     image->makeNonTextureImage();
 
-    uint64_t pointer = getContext()->makePlatformBuffer(image);
+    uint64_t pointer = getContext()->makeNativeBuffer(image);
     jsi::HostFunctionType deleteFunc =
         [=](jsi::Runtime &runtime, const jsi::Value &thisArg,
             const jsi::Value *args, size_t count) -> jsi::Value {
-      getContext()->releasePlatformBuffer(pointer);
+      getContext()->releaseNativeBuffer(pointer);
       return jsi::Value::undefined();
     };
     return jsi::BigInt::fromUint64(runtime, pointer);
@@ -36,7 +36,7 @@ public:
     jsi::BigInt pointer = arguments[0].asBigInt(runtime);
     const uintptr_t platformBufferPointer = pointer.asUint64(runtime);
 
-    getContext()->releasePlatformBuffer(platformBufferPointer);
+    getContext()->releaseNativeBuffer(platformBufferPointer);
     return jsi::Value::undefined();
   }
 
diff --git a/node_modules/@shopify/react-native-skia/cpp/api/JsiSkImageFactory.h b/node_modules/@shopify/react-native-skia/cpp/api/JsiSkImageFactory.h
index 19ae0b9..f3dfcab 100644
--- a/node_modules/@shopify/react-native-skia/cpp/api/JsiSkImageFactory.h
+++ b/node_modules/@shopify/react-native-skia/cpp/api/JsiSkImageFactory.h
@@ -31,7 +31,7 @@ public:
     jsi::BigInt pointer = arguments[0].asBigInt(runtime);
     const uintptr_t platformBufferPointer = pointer.asUint64(runtime);
     void *rawPointer = reinterpret_cast<void *>(platformBufferPointer);
-    auto image = getContext()->makeImageFromPlatformBuffer(rawPointer);
+    auto image = getContext()->makeImageFromNativeBuffer(rawPointer);
     if (image == nullptr) {
       throw std::runtime_error("Failed to convert PlatformBuffer to SkImage!");
     }
diff --git a/node_modules/@shopify/react-native-skia/cpp/rnskia/RNSkPlatformContext.h b/node_modules/@shopify/react-native-skia/cpp/rnskia/RNSkPlatformContext.h
index 03a038e..7f03215 100644
--- a/node_modules/@shopify/react-native-skia/cpp/rnskia/RNSkPlatformContext.h
+++ b/node_modules/@shopify/react-native-skia/cpp/rnskia/RNSkPlatformContext.h
@@ -134,17 +134,17 @@ public:
   virtual sk_sp<SkSurface> makeOffscreenSurface(int width, int height) = 0;
 
   /**
-   * Creates an image from a native platform buffer.
+   * Creates an image from a native buffer.
    * - On iOS, this is a `CMSampleBuffer`
    * - On Android, this is a `AHardwareBuffer*`
    * @param buffer The native platform buffer.
    * @return sk_sp<SkImage>
    */
-  virtual sk_sp<SkImage> makeImageFromPlatformBuffer(void *buffer) = 0;
+  virtual sk_sp<SkImage> makeImageFromNativeBuffer(void *buffer) = 0;
 
-  virtual void releasePlatformBuffer(uint64_t pointer) = 0;
+  virtual void releaseNativeBuffer(uint64_t pointer) = 0;
 
-  virtual uint64_t makePlatformBuffer(sk_sp<SkImage> image) = 0;
+  virtual uint64_t makeNativeBuffer(sk_sp<SkImage> image) = 0;
 
   /**
    * Return the Platform specific font manager
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkMetalCanvasProvider.mm b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkMetalCanvasProvider.mm
index 0c73eee..5738746 100644
--- a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkMetalCanvasProvider.mm
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkMetalCanvasProvider.mm
@@ -92,9 +92,8 @@
       dContext->flushAndSubmit();
     }
 
-    id<MTLCommandBuffer> commandBuffer(
-        [ThreadContextHolder::ThreadSkiaMetalContext
-                .commandQueue commandBuffer]);
+    auto &context = SkiaMetalSurfaceFactory::getSkiaContext();
+    id<MTLCommandBuffer> commandBuffer = context.commandQueue.commandBuffer;
     [commandBuffer presentDrawable:currentDrawable];
     [commandBuffer commit];
   }
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.h b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.h
index 92dd6eb..b3bbc32 100644
--- a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.h
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.h
@@ -59,11 +59,11 @@ public:
 
   sk_sp<SkImage> takeScreenshotFromViewTag(size_t tag) override;
 
-  sk_sp<SkImage> makeImageFromPlatformBuffer(void *buffer) override;
+  sk_sp<SkImage> makeImageFromNativeBuffer(void *buffer) override;
 
-  uint64_t makePlatformBuffer(sk_sp<SkImage> image) override;
+  uint64_t makeNativeBuffer(sk_sp<SkImage> image) override;
 
-  void releasePlatformBuffer(uint64_t pointer) override;
+  void releaseNativeBuffer(uint64_t pointer) override;
 
   virtual void performStreamOperation(
       const std::string &sourceUri,
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.mm b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.mm
index b3134ee..50953dc 100644
--- a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.mm
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/RNSkiOSPlatformContext.mm
@@ -1,11 +1,12 @@
-#include "RNSkiOSPlatformContext.h"
+#import "RNSkiOSPlatformContext.h"
 
 #import <CoreMedia/CMSampleBuffer.h>
 #import <React/RCTUtils.h>
 #include <thread>
 #include <utility>
 
-#include "SkiaMetalSurfaceFactory.h"
+#import "SkiaCVPixelBufferUtils.h"
+#import "SkiaMetalSurfaceFactory.h"
 
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdocumentation"
@@ -57,7 +58,7 @@
   std::thread(loader).detach();
 }
 
-void RNSkiOSPlatformContext::releasePlatformBuffer(uint64_t pointer) {
+void RNSkiOSPlatformContext::releaseNativeBuffer(uint64_t pointer) {
   CMSampleBufferRef sampleBuffer = reinterpret_cast<CMSampleBufferRef>(pointer);
   CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
   if (sampleBuffer) {
@@ -68,64 +69,95 @@
   }
 }
 
-uint64_t RNSkiOSPlatformContext::makePlatformBuffer(sk_sp<SkImage> image) {
+uint64_t RNSkiOSPlatformContext::makeNativeBuffer(sk_sp<SkImage> image) {
+  // 0. If Image is not in BGRA, convert to BGRA as only BGRA is supported.
+  if (image->colorType() != kBGRA_8888_SkColorType) {
+    const auto& context = SkiaMetalSurfaceFactory::getSkiaContext();
+    // on iOS, 32_BGRA is the only supported RGB format for CVPixelBuffers.
+    image = image->makeColorTypeAndColorSpace(
+        context.skContext.get(),
+        kBGRA_8888_SkColorType, SkColorSpace::MakeSRGB());
+    if (image == nullptr) {
+      throw std::runtime_error(
+          "Failed to convert image to BGRA_8888 colortype! Only BGRA_8888 "
+          "PlatformBuffers are supported.");
+    }
+  }
+
+  // 1. Get image info
   auto bytesPerPixel = image->imageInfo().bytesPerPixel();
   int bytesPerRow = image->width() * bytesPerPixel;
   auto buf = SkData::MakeUninitialized(image->width() * image->height() *
                                        bytesPerPixel);
   SkImageInfo info = SkImageInfo::Make(image->width(), image->height(),
                                        image->colorType(), image->alphaType());
+  // 2. Copy pixels into our buffer
   image->readPixels(nullptr, info, const_cast<void *>(buf->data()), bytesPerRow,
                     0, 0);
-  auto pixelData = const_cast<void *>(buf->data());
 
-  // Create a CVPixelBuffer from the raw pixel data
-  CVPixelBufferRef pixelBuffer = nullptr;
-  // OSType pixelFormatType = MapSkColorTypeToOSType(image->colorType());
-
-  // You will need to fill in the details for creating the pixel buffer
-  // CVPixelBufferCreateWithBytes or CVPixelBufferCreateWithPlanarBytes
-  // Create the CVPixelBuffer with the image data
-  void *context = static_cast<void *>(
-      new sk_sp<SkData>(buf)); // Create a copy for the context
-  CVReturn r = CVPixelBufferCreateWithBytes(
-      nullptr, // allocator
-      image->width(), image->height(), kCVPixelFormatType_32BGRA,
-      pixelData,                                         // pixel data
-      bytesPerRow,                                       // bytes per row
-      [](void *releaseRefCon, const void *baseAddress) { // release callback
-        auto buf = static_cast<sk_sp<SkData> *>(releaseRefCon);
-        buf->reset(); // This effectively calls unref on the SkData object
-        delete buf;   // Cleanup the dynamically allocated context
-      },
-      context,     // release callback context
-      nullptr,     // pixel buffer attributes
-      &pixelBuffer // the newly created pixel buffer
-  );
-
-  if (r != kCVReturnSuccess) {
-    return 0; // or handle error appropriately
+  // 3. Create an IOSurface (GPU + CPU memory)
+  CFMutableDictionaryRef dict = CFDictionaryCreateMutable(
+      kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks,
+      &kCFTypeDictionaryValueCallBacks);
+  int width = image->width();
+  int height = image->height();
+  int pitch = width * bytesPerPixel;
+  int size = width * height * bytesPerPixel;
+  OSType pixelFormat = kCVPixelFormatType_32BGRA;
+  CFDictionarySetValue(
+      dict, kIOSurfaceBytesPerRow,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pitch));
+  CFDictionarySetValue(
+      dict, kIOSurfaceBytesPerElement,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &bytesPerPixel));
+  CFDictionarySetValue(
+      dict, kIOSurfaceWidth,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &width));
+  CFDictionarySetValue(
+      dict, kIOSurfaceHeight,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &height));
+  CFDictionarySetValue(
+      dict, kIOSurfacePixelFormat,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &pixelFormat));
+  CFDictionarySetValue(
+      dict, kIOSurfaceAllocSize,
+      CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &size));
+  IOSurfaceRef surface = IOSurfaceCreate(dict);
+  if (surface == nil) {
+    throw std::runtime_error("Failed to create " + std::to_string(width) + "x" +
+                             std::to_string(height) + " IOSurface!");
   }
 
-  // Wrap the CVPixelBuffer in a CMSampleBuffer
-  CMSampleBufferRef sampleBuffer = nullptr;
+  // 4. Copy over the memory from the pixels into the IOSurface
+  IOSurfaceLock(surface, 0, nil);
+  void *base = IOSurfaceGetBaseAddress(surface);
+  memcpy(base, buf->data(), buf->size());
+  IOSurfaceUnlock(surface, 0, nil);
+
+  // 5. Create a CVPixelBuffer from the IOSurface
+  CVPixelBufferRef pixelBuffer = nullptr;
+  CVReturn result =
+      CVPixelBufferCreateWithIOSurface(nil, surface, nil, &pixelBuffer);
+  if (result != kCVReturnSuccess) {
+    throw std::runtime_error(
+        "Failed to create CVPixelBuffer from SkImage! Return value: " +
+        std::to_string(result));
+  }
 
+  // 6. Create CMSampleBuffer base information
   CMFormatDescriptionRef formatDescription = nullptr;
   CMVideoFormatDescriptionCreateForImageBuffer(kCFAllocatorDefault, pixelBuffer,
                                                &formatDescription);
-
-  // Assuming no specific timing is required, we initialize the timing info to
-  // zero.
   CMSampleTimingInfo timingInfo = {0};
-  timingInfo.duration = kCMTimeInvalid; // Indicate an unknown duration.
-  timingInfo.presentationTimeStamp = kCMTimeZero; // Start at time zero.
-  timingInfo.decodeTimeStamp = kCMTimeInvalid;    // No specific decode time.
+  timingInfo.duration = kCMTimeInvalid;
+  timingInfo.presentationTimeStamp = kCMTimeZero;
+  timingInfo.decodeTimeStamp = kCMTimeInvalid;
 
-  // Create the sample buffer.
+  // 7. Wrap the CVPixelBuffer in a CMSampleBuffer
+  CMSampleBufferRef sampleBuffer = nullptr;
   OSStatus status = CMSampleBufferCreateReadyWithImageBuffer(
       kCFAllocatorDefault, pixelBuffer, formatDescription, &timingInfo,
       &sampleBuffer);
-
   if (status != noErr) {
     if (formatDescription) {
       CFRelease(formatDescription);
@@ -133,10 +165,12 @@
     if (pixelBuffer) {
       CFRelease(pixelBuffer);
     }
-    return 0;
+    throw std::runtime_error(
+        "Failed to wrap CVPixelBuffer in CMSampleBuffer! Return value: " +
+        std::to_string(status));
   }
 
-  // Return sampleBuffer casted to uint64_t
+  // 8. Return CMsampleBuffer casted to uint64_t
   return reinterpret_cast<uint64_t>(sampleBuffer);
 }
 
@@ -149,35 +183,9 @@
   return SkiaMetalSurfaceFactory::makeOffscreenSurface(width, height);
 }
 
-sk_sp<SkImage>
-RNSkiOSPlatformContext::makeImageFromPlatformBuffer(void *buffer) {
+sk_sp<SkImage> RNSkiOSPlatformContext::makeImageFromNativeBuffer(void *buffer) {
   CMSampleBufferRef sampleBuffer = (CMSampleBufferRef)buffer;
-  // DO the CPU transfer (debugging only)
-  //  Step 1: Extract the CVPixelBufferRef from the CMSampleBufferRef
-  CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
-
-  // Step 2: Lock the pixel buffer to access the raw pixel data
-  CVPixelBufferLockBaseAddress(pixelBuffer, 0);
-
-  // Step 3: Get information about the image
-  void *baseAddress = CVPixelBufferGetBaseAddress(pixelBuffer);
-  size_t width = CVPixelBufferGetWidth(pixelBuffer);
-  size_t height = CVPixelBufferGetHeight(pixelBuffer);
-  size_t bytesPerRow = CVPixelBufferGetBytesPerRow(pixelBuffer);
-
-  // Assuming the pixel format is 32BGRA, which is common for iOS video frames.
-  // You might need to adjust this based on the actual pixel format.
-  SkImageInfo info = SkImageInfo::Make(width, height, kRGBA_8888_SkColorType,
-                                       kUnpremul_SkAlphaType);
-
-  // Step 4: Create an SkImage from the pixel buffer
-  sk_sp<SkData> data =
-      SkData::MakeWithoutCopy(baseAddress, height * bytesPerRow);
-  sk_sp<SkImage> image = SkImages::RasterFromData(info, data, bytesPerRow);
-  auto texture = SkiaMetalSurfaceFactory::makeTextureFromImage(image);
-  // Step 5: Unlock the pixel buffer
-  CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
-  return texture;
+  return SkiaMetalSurfaceFactory::makeTextureFromCMSampleBuffer(sampleBuffer);
 }
 
 sk_sp<SkFontMgr> RNSkiOSPlatformContext::createFontMgr() {
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.h b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.h
new file mode 100644
index 0000000..1d8f15c
--- /dev/null
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.h
@@ -0,0 +1,70 @@
+//
+//  SkiaCVPixelBufferUtils.h
+//  react-native-skia
+//
+//  Created by Marc Rousavy on 10.04.24.
+//
+
+#pragma once
+#import <CoreMedia/CMSampleBuffer.h>
+#import <CoreVideo/CVMetalTextureCache.h>
+#import <MetalKit/MetalKit.h>
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdocumentation"
+#import "include/core/SkColorSpace.h"
+#import "include/gpu/GrBackendSurface.h"
+#import "include/gpu/GrYUVABackendTextures.h"
+#pragma clang diagnostic pop
+
+class SkiaCVPixelBufferUtils {
+public:
+  enum class CVPixelBufferBaseFormat { rgb, yuv };
+
+  /**
+   Get the base format (currently only RGB) of the PixelBuffer.
+   Depending on the base-format, different methods have to be used to create
+   Skia buffers.
+   */
+  static CVPixelBufferBaseFormat
+  getCVPixelBufferBaseFormat(CVPixelBufferRef pixelBuffer);
+
+  class RGB {
+  public:
+    /**
+     Gets the Skia Color Type of the RGB pixel-buffer.
+     */
+    static SkColorType getCVPixelBufferColorType(CVPixelBufferRef pixelBuffer);
+    /**
+     Gets a GPU-backed Skia Texture for the given RGB CVPixelBuffer.
+     */
+    static GrBackendTexture
+    getSkiaTextureForCVPixelBuffer(CVPixelBufferRef pixelBuffer);
+  };
+
+  class YUV {
+  public:
+    /**
+     Gets one or more GPU-backed Skia Textures for the given YUV CVPixelBuffer.
+     The size of the resulting textures depends on the amount of planes in the
+     CVPixelBuffer.
+     */
+    static GrYUVABackendTextures
+    getSkiaTextureForCVPixelBuffer(CVPixelBufferRef pixelBuffer);
+
+  private:
+    static SkYUVAInfo::PlaneConfig getPlaneConfig(OSType pixelFormat);
+    static SkYUVAInfo::Subsampling getSubsampling(OSType pixelFormat);
+    static SkYUVColorSpace getColorspace(OSType pixelFormat);
+    static SkYUVAInfo getYUVAInfoForCVPixelBuffer(CVPixelBufferRef pixelBuffer);
+  };
+
+private:
+  static CVMetalTextureCacheRef getTextureCache();
+  static GrBackendTexture
+  getSkiaTextureForCVPixelBufferPlane(CVPixelBufferRef pixelBuffer,
+                                      size_t planeIndex);
+  static MTLPixelFormat
+  getMTLPixelFormatForCVPixelBufferPlane(CVPixelBufferRef pixelBuffer,
+                                         size_t planeIndex);
+};
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.mm b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.mm
new file mode 100644
index 0000000..33994e5
--- /dev/null
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaCVPixelBufferUtils.mm
@@ -0,0 +1,327 @@
+//
+//  SkiaCVPixelBufferUtils.mm
+//  react-native-skia
+//
+//  Created by Marc Rousavy on 10.04.24.
+//
+
+#import "SkiaCVPixelBufferUtils.h"
+#import "SkiaMetalSurfaceFactory.h"
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdocumentation"
+#import "include/core/SkColorSpace.h"
+#import <include/gpu/GrBackendSurface.h>
+#pragma clang diagnostic pop
+
+#include <TargetConditionals.h>
+#if TARGET_RT_BIG_ENDIAN
+#define FourCC2Str(fourcc)                                                     \
+  (const char[]) {                                                             \
+    *((char *)&fourcc), *(((char *)&fourcc) + 1), *(((char *)&fourcc) + 2),    \
+        *(((char *)&fourcc) + 3), 0                                            \
+  }
+#else
+#define FourCC2Str(fourcc)                                                     \
+  (const char[]) {                                                             \
+    *(((char *)&fourcc) + 3), *(((char *)&fourcc) + 2),                        \
+        *(((char *)&fourcc) + 1), *(((char *)&fourcc) + 0), 0                  \
+  }
+#endif
+
+// pragma MARK: Base
+
+SkiaCVPixelBufferUtils::CVPixelBufferBaseFormat
+SkiaCVPixelBufferUtils::getCVPixelBufferBaseFormat(
+    CVPixelBufferRef pixelBuffer) {
+  OSType format = CVPixelBufferGetPixelFormatType(pixelBuffer);
+
+  switch (format) {
+  // 8-bit YUV formats
+  case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarFullRange:
+  // 10-bit YUV formats
+  case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
+    return CVPixelBufferBaseFormat::yuv;
+  case kCVPixelFormatType_24RGB:
+  case kCVPixelFormatType_24BGR:
+  case kCVPixelFormatType_32ARGB:
+  case kCVPixelFormatType_32BGRA:
+  case kCVPixelFormatType_32ABGR:
+  case kCVPixelFormatType_32RGBA:
+  case kCVPixelFormatType_64ARGB:
+  case kCVPixelFormatType_64RGBALE:
+  case kCVPixelFormatType_48RGB:
+  case kCVPixelFormatType_30RGB:
+    return CVPixelBufferBaseFormat::rgb;
+  default:
+    [[unlikely]] throw std::runtime_error(
+        "CVPixelBuffer has unknown pixel format! " +
+        std::string("Expected: any RGB or YUV format, Received: ") +
+        std::string(FourCC2Str(format)));
+  }
+}
+
+// pragma MARK: RGB
+
+SkColorType SkiaCVPixelBufferUtils::RGB::getCVPixelBufferColorType(
+    CVPixelBufferRef pixelBuffer) {
+  OSType format = CVPixelBufferGetPixelFormatType(pixelBuffer);
+
+  switch (format) {
+  case kCVPixelFormatType_32BGRA:
+    [[likely]] return kBGRA_8888_SkColorType;
+  case kCVPixelFormatType_32RGBA:
+    return kRGBA_8888_SkColorType;
+  // This can be extended with branches for specific RGB formats if Apple
+  // uses new formats.
+  default:
+    [[unlikely]] throw std::runtime_error(
+        "CVPixelBuffer has unknown RGB format! " +
+        std::string(FourCC2Str(format)));
+  }
+}
+
+GrBackendTexture SkiaCVPixelBufferUtils::RGB::getSkiaTextureForCVPixelBuffer(
+    CVPixelBufferRef pixelBuffer) {
+  return getSkiaTextureForCVPixelBufferPlane(pixelBuffer, /* planeIndex */ 0);
+}
+
+// pragma MARK: YUV
+
+GrYUVABackendTextures
+SkiaCVPixelBufferUtils::YUV::getSkiaTextureForCVPixelBuffer(
+    CVPixelBufferRef pixelBuffer) {
+  // 1. Get all planes (YUV, Y_UV, Y_U_V or Y_U_V_A)
+  size_t planesCount = CVPixelBufferGetPlaneCount(pixelBuffer);
+  GrBackendTexture textures[planesCount];
+
+  for (size_t planeIndex = 0; planeIndex < planesCount; planeIndex++) {
+    textures[planeIndex] =
+        getSkiaTextureForCVPixelBufferPlane(pixelBuffer, planeIndex);
+  }
+
+  // 2. Wrap info about buffer
+  SkYUVAInfo info = getYUVAInfoForCVPixelBuffer(pixelBuffer);
+
+  // 3. Return all textures
+  return GrYUVABackendTextures(info, textures, kTopLeft_GrSurfaceOrigin);
+}
+
+SkYUVAInfo SkiaCVPixelBufferUtils::YUV::getYUVAInfoForCVPixelBuffer(
+    CVPixelBufferRef pixelBuffer) {
+  size_t width = CVPixelBufferGetWidth(pixelBuffer);
+  size_t height = CVPixelBufferGetHeight(pixelBuffer);
+  SkISize size =
+      SkISize::Make(static_cast<int>(width), static_cast<int>(height));
+
+  OSType format = CVPixelBufferGetPixelFormatType(pixelBuffer);
+  SkYUVAInfo::PlaneConfig planeConfig = getPlaneConfig(format);
+  SkYUVAInfo::Subsampling subsampling = getSubsampling(format);
+  SkYUVColorSpace colorspace = getColorspace(format);
+
+  return SkYUVAInfo(size, planeConfig, subsampling, colorspace);
+}
+
+// pragma MARK: YUV getPlaneConfig()
+
+SkYUVAInfo::PlaneConfig
+SkiaCVPixelBufferUtils::YUV::getPlaneConfig(OSType pixelFormat) {
+  switch (pixelFormat) {
+  case kCVPixelFormatType_420YpCbCr8Planar:
+  case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
+    return SkYUVAInfo::PlaneConfig::kYUV;
+  case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr16BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr16BiPlanarVideoRange:
+    [[likely]] return SkYUVAInfo::PlaneConfig::kY_UV;
+  case kCVPixelFormatType_420YpCbCr8VideoRange_8A_TriPlanar:
+  case kCVPixelFormatType_444YpCbCr16VideoRange_16A_TriPlanar:
+    return SkYUVAInfo::PlaneConfig::kY_U_V;
+  // This can be extended with branches for specific YUV formats if Apple
+  // uses new formats.
+  default:
+    [[unlikely]] throw std::runtime_error("Invalid pixel format! " +
+                                          std::string(FourCC2Str(pixelFormat)));
+  }
+}
+
+// pragma MARK: YUV getSubsampling()
+
+SkYUVAInfo::Subsampling
+SkiaCVPixelBufferUtils::YUV::getSubsampling(OSType pixelFormat) {
+  switch (pixelFormat) {
+  case kCVPixelFormatType_420YpCbCr8Planar:
+  case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_420YpCbCr8VideoRange_8A_TriPlanar:
+    [[likely]] return SkYUVAInfo::Subsampling::k420;
+  case kCVPixelFormatType_4444YpCbCrA8:
+  case kCVPixelFormatType_4444YpCbCrA8R:
+  case kCVPixelFormatType_4444AYpCbCr8:
+  case kCVPixelFormatType_4444AYpCbCr16:
+  case kCVPixelFormatType_4444AYpCbCrFloat:
+  case kCVPixelFormatType_444YpCbCr8:
+  case kCVPixelFormatType_444YpCbCr10:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr16BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr16VideoRange_16A_TriPlanar:
+    return SkYUVAInfo::Subsampling::k444;
+  case kCVPixelFormatType_422YpCbCr8:
+  case kCVPixelFormatType_422YpCbCr16:
+  case kCVPixelFormatType_422YpCbCr10:
+  case kCVPixelFormatType_422YpCbCr_4A_8BiPlanar:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr8_yuvs:
+  case kCVPixelFormatType_422YpCbCr8FullRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr16BiPlanarVideoRange:
+    return SkYUVAInfo::Subsampling::k422;
+  // This can be extended with branches for specific YUV formats if Apple
+  // uses new formats.
+  default:
+    [[unlikely]] throw std::runtime_error("Invalid pixel format! " +
+                                          std::string(FourCC2Str(pixelFormat)));
+  }
+}
+
+// pragma MARK: YUV getColorspace()
+
+SkYUVColorSpace SkiaCVPixelBufferUtils::YUV::getColorspace(OSType pixelFormat) {
+  switch (pixelFormat) {
+  case kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarVideoRange:
+    [[likely]]
+    // 8-bit limited
+    return SkYUVColorSpace::kRec709_Limited_SkYUVColorSpace;
+  case kCVPixelFormatType_420YpCbCr8PlanarFullRange:
+  case kCVPixelFormatType_420YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr8BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr8FullRange:
+    [[likely]]
+    // 8-bit full
+    return SkYUVColorSpace::kRec709_Full_SkYUVColorSpace;
+  case kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange:
+    // 10-bit limited
+    return SkYUVColorSpace::kBT2020_10bit_Limited_SkYUVColorSpace;
+  case kCVPixelFormatType_420YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_422YpCbCr10BiPlanarFullRange:
+  case kCVPixelFormatType_444YpCbCr10BiPlanarFullRange:
+    // 10-bit full
+    return SkYUVColorSpace::kBT2020_10bit_Full_SkYUVColorSpace;
+  // This can be extended with branches for specific YUV formats if Apple
+  // uses new formats.
+  default:
+    [[unlikely]] throw std::runtime_error("Invalid pixel format! " +
+                                          std::string(FourCC2Str(pixelFormat)));
+  }
+}
+
+// pragma MARK: CVPixelBuffer -> Skia Texture
+
+GrBackendTexture SkiaCVPixelBufferUtils::getSkiaTextureForCVPixelBufferPlane(
+    CVPixelBufferRef pixelBuffer, size_t planeIndex) {
+  // 1. Get cache
+  CVMetalTextureCacheRef textureCache = getTextureCache();
+
+  // 2. Get MetalTexture from CMSampleBuffer
+  CVMetalTextureRef textureHolder;
+  size_t width = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex);
+  size_t height = CVPixelBufferGetHeightOfPlane(pixelBuffer, planeIndex);
+  MTLPixelFormat pixelFormat =
+      getMTLPixelFormatForCVPixelBufferPlane(pixelBuffer, planeIndex);
+  CVReturn result = CVMetalTextureCacheCreateTextureFromImage(
+      kCFAllocatorDefault, textureCache, pixelBuffer, nil, pixelFormat, width,
+      height, planeIndex, &textureHolder);
+  if (result != kCVReturnSuccess) [[unlikely]] {
+    throw std::runtime_error(
+        "Failed to create Metal Texture from CMSampleBuffer! Result: " +
+        std::to_string(result));
+  }
+
+  // 2. Unwrap the underlying MTLTexture
+  id<MTLTexture> mtlTexture = CVMetalTextureGetTexture(textureHolder);
+  if (mtlTexture == nil) [[unlikely]] {
+    throw std::runtime_error(
+        "Failed to get MTLTexture from CVMetalTextureRef!");
+  }
+
+  // 3. Wrap MTLTexture in Skia's GrBackendTexture
+  GrMtlTextureInfo textureInfo;
+  textureInfo.fTexture.retain((__bridge void *)mtlTexture);
+  GrBackendTexture texture =
+      GrBackendTexture((int)mtlTexture.width, (int)mtlTexture.height,
+                       skgpu::Mipmapped::kNo, textureInfo);
+  CFRelease(textureHolder);
+  return texture;
+}
+
+// pragma MARK: getTextureCache()
+
+CVMetalTextureCacheRef SkiaCVPixelBufferUtils::getTextureCache() {
+  static thread_local CVMetalTextureCacheRef textureCache = nil;
+  if (textureCache == nil) {
+    // Create a new Texture Cache
+    auto result = CVMetalTextureCacheCreate(kCFAllocatorDefault, nil,
+                                            MTLCreateSystemDefaultDevice(), nil,
+                                            &textureCache);
+    if (result != kCVReturnSuccess || textureCache == nil) {
+      throw std::runtime_error("Failed to create Metal Texture Cache!");
+    }
+  }
+  return textureCache;
+}
+
+// pragma MARK: Get CVPixelBuffer MTLPixelFormat
+
+MTLPixelFormat SkiaCVPixelBufferUtils::getMTLPixelFormatForCVPixelBufferPlane(
+    CVPixelBufferRef pixelBuffer, size_t planeIndex) {
+  size_t width = CVPixelBufferGetWidthOfPlane(pixelBuffer, planeIndex);
+  size_t bytesPerRow =
+      CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, planeIndex);
+  double bytesPerPixel = round(static_cast<double>(bytesPerRow) / width);
+  if (bytesPerPixel == 1) {
+    return MTLPixelFormatR8Unorm;
+  } else if (bytesPerPixel == 2) {
+    return MTLPixelFormatRG8Unorm;
+  } else if (bytesPerPixel == 4) {
+    return MTLPixelFormatBGRA8Unorm;
+  } else [[unlikely]] {
+    throw std::runtime_error("Invalid bytes per row! Expected 1 (R), 2 (RG) or "
+                             "4 (RGBA), but received " +
+                             std::to_string(bytesPerPixel));
+  }
+}
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.h b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.h
index 8d9ac40..439fcd8 100644
--- a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.h
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.h
@@ -11,25 +11,19 @@
 #pragma clang diagnostic pop
 
 using SkiaMetalContext = struct SkiaMetalContext {
-  id<MTLCommandQueue> commandQueue = nullptr;
+  id<MTLDevice> device = nil;
+  id<MTLCommandQueue> commandQueue = nil;
   sk_sp<GrDirectContext> skContext = nullptr;
 };
 
-class ThreadContextHolder {
-public:
-  static thread_local SkiaMetalContext ThreadSkiaMetalContext;
-};
-
 class SkiaMetalSurfaceFactory {
 public:
   static sk_sp<SkSurface> makeWindowedSurface(id<MTLTexture> texture, int width,
                                               int height);
   static sk_sp<SkSurface> makeOffscreenSurface(int width, int height);
 
-  static sk_sp<SkImage> makeTextureFromImage(sk_sp<SkImage> image);
+  static sk_sp<SkImage>
+  makeTextureFromCMSampleBuffer(CMSampleBufferRef sampleBuffer);
 
-private:
-  static id<MTLDevice> device;
-  static bool
-  createSkiaDirectContextIfNecessary(SkiaMetalContext *threadContext);
+  static const SkiaMetalContext &getSkiaContext();
 };
diff --git a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.mm b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.mm
index 0e95d2c..e62956d 100644
--- a/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.mm
+++ b/node_modules/@shopify/react-native-skia/ios/RNSkia-iOS/SkiaMetalSurfaceFactory.mm
@@ -1,6 +1,7 @@
 #import "RNSkLog.h"
 
-#include "SkiaMetalSurfaceFactory.h"
+#import "SkiaCVPixelBufferUtils.h"
+#import "SkiaMetalSurfaceFactory.h"
 
 #pragma clang diagnostic push
 #pragma clang diagnostic ignored "-Wdocumentation"
@@ -17,8 +18,6 @@
 
 #pragma clang diagnostic pop
 
-thread_local SkiaMetalContext ThreadContextHolder::ThreadSkiaMetalContext;
-
 struct OffscreenRenderContext {
   id<MTLTexture> texture;
 
@@ -38,40 +37,59 @@
   }
 };
 
-id<MTLDevice> SkiaMetalSurfaceFactory::device = MTLCreateSystemDefaultDevice();
-
-bool SkiaMetalSurfaceFactory::createSkiaDirectContextIfNecessary(
-    SkiaMetalContext *skiaMetalContext) {
-  if (skiaMetalContext->skContext == nullptr) {
-    skiaMetalContext->commandQueue =
-        id<MTLCommandQueue>(CFRetain((GrMTLHandle)[device newCommandQueue]));
-    skiaMetalContext->skContext = GrDirectContext::MakeMetal(
-        (__bridge void *)device,
-        (__bridge void *)skiaMetalContext->commandQueue);
-    if (skiaMetalContext->skContext == nullptr) {
-      RNSkia::RNSkLogger::logToConsole("Couldn't create a Skia Metal Context");
-      return false;
+const SkiaMetalContext &SkiaMetalSurfaceFactory::getSkiaContext() {
+  // this key is just used as a pointer reference.
+  static const auto key = 1;
+
+  void *state = dispatch_get_specific(&key);
+  if (state == nullptr) {
+    NSLog(@"Re-creating SkiaContext...");
+    SkiaMetalContext *context = new SkiaMetalContext();
+    context->device = MTLCreateSystemDefaultDevice();
+    context->commandQueue = [context->device newCommandQueue];
+    sk_sp<GrDirectContext> skContext =
+        GrDirectContext::MakeMetal((__bridge void *)context->device,
+                                   (__bridge void *)context->commandQueue);
+    if (skContext == nullptr) {
+      throw std::runtime_error("Failed to create Metal Skia Context!");
     }
+    context->skContext = skContext;
+
+    state = reinterpret_cast<void *>(context);
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated-declarations"
+    // Instead of using thread_local, we store the current SkContext
+    // in the current dispatch queue's specific storage.
+    // The problem with thread_local is that Dispatch Queues on iOS
+    // may use multiple Threads, even when using serial (non-concurrent)
+    // attributes, which caused the SkContext to re-initialize
+    // even though it should remain the same - this caused flickering
+    // in NativeBuffer() APIs (e.g. VisionCamera or Video)
+    dispatch_queue_t currentQueue = dispatch_get_current_queue();
+#pragma clang diagnostic pop
+    dispatch_queue_set_specific(currentQueue, &key, state, [](void *data) {
+      delete reinterpret_cast<SkiaMetalContext *>(data);
+    });
   }
-  return true;
+
+  SkiaMetalContext *currentContext =
+      reinterpret_cast<SkiaMetalContext *>(state);
+  return *currentContext;
 }
 
 sk_sp<SkSurface>
 SkiaMetalSurfaceFactory::makeWindowedSurface(id<MTLTexture> texture, int width,
                                              int height) {
-  // Get render context for current thread
-  if (!SkiaMetalSurfaceFactory::createSkiaDirectContextIfNecessary(
-          &ThreadContextHolder::ThreadSkiaMetalContext)) {
-    return nullptr;
-  }
   GrMtlTextureInfo fbInfo;
   fbInfo.fTexture.retain((__bridge void *)texture);
 
   GrBackendRenderTarget backendRT(width, height, fbInfo);
 
+  auto &context = getSkiaContext();
   auto skSurface = SkSurfaces::WrapBackendRenderTarget(
-      ThreadContextHolder::ThreadSkiaMetalContext.skContext.get(), backendRT,
-      kTopLeft_GrSurfaceOrigin, kBGRA_8888_SkColorType, nullptr, nullptr);
+      context.skContext.get(), backendRT, kTopLeft_GrSurfaceOrigin,
+      kBGRA_8888_SkColorType, nullptr, nullptr);
 
   if (skSurface == nullptr || skSurface->getCanvas() == nullptr) {
     RNSkia::RNSkLogger::logToConsole(
@@ -83,13 +101,9 @@
 
 sk_sp<SkSurface> SkiaMetalSurfaceFactory::makeOffscreenSurface(int width,
                                                                int height) {
-  if (!SkiaMetalSurfaceFactory::createSkiaDirectContextIfNecessary(
-          &ThreadContextHolder::ThreadSkiaMetalContext)) {
-    return nullptr;
-  }
-  auto ctx = new OffscreenRenderContext(
-      device, ThreadContextHolder::ThreadSkiaMetalContext.skContext,
-      ThreadContextHolder::ThreadSkiaMetalContext.commandQueue, width, height);
+  auto &context = getSkiaContext();
+  auto ctx = new OffscreenRenderContext(context.device, context.skContext,
+                                        context.commandQueue, width, height);
 
   // Create a GrBackendTexture from the Metal texture
   GrMtlTextureInfo info;
@@ -98,20 +112,49 @@
 
   // Create a SkSurface from the GrBackendTexture
   auto surface = SkSurfaces::WrapBackendTexture(
-      ThreadContextHolder::ThreadSkiaMetalContext.skContext.get(),
-      backendTexture, kTopLeft_GrSurfaceOrigin, 0, kBGRA_8888_SkColorType,
-      nullptr, nullptr,
+      context.skContext.get(), backendTexture, kTopLeft_GrSurfaceOrigin, 0,
+      kBGRA_8888_SkColorType, nullptr, nullptr,
       [](void *addr) { delete (OffscreenRenderContext *)addr; }, ctx);
 
   return surface;
 }
 
-sk_sp<SkImage>
-SkiaMetalSurfaceFactory::makeTextureFromImage(sk_sp<SkImage> image) {
-  if (!SkiaMetalSurfaceFactory::createSkiaDirectContextIfNecessary(
-          &ThreadContextHolder::ThreadSkiaMetalContext)) {
-    throw std::runtime_error("Failed to create Skia Context for this Thread!");
+sk_sp<SkImage> SkiaMetalSurfaceFactory::makeTextureFromCMSampleBuffer(
+    CMSampleBufferRef sampleBuffer) {
+  auto &context = getSkiaContext();
+
+  if (!CMSampleBufferIsValid(sampleBuffer)) [[unlikely]] {
+    throw std::runtime_error("The given CMSampleBuffer is not valid!");
+  }
+
+  CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
+
+  SkiaCVPixelBufferUtils::CVPixelBufferBaseFormat format =
+      SkiaCVPixelBufferUtils::getCVPixelBufferBaseFormat(pixelBuffer);
+  switch (format) {
+  case SkiaCVPixelBufferUtils::CVPixelBufferBaseFormat::rgb: {
+    // CVPixelBuffer is in any RGB format.
+    SkColorType colorType =
+        SkiaCVPixelBufferUtils::RGB::getCVPixelBufferColorType(pixelBuffer);
+    GrBackendTexture texture =
+        SkiaCVPixelBufferUtils::RGB::getSkiaTextureForCVPixelBuffer(
+            pixelBuffer);
+    return SkImages::AdoptTextureFrom(context.skContext.get(), texture,
+                                      kTopLeft_GrSurfaceOrigin, colorType,
+                                      kOpaque_SkAlphaType);
+  }
+  case SkiaCVPixelBufferUtils::CVPixelBufferBaseFormat::yuv: {
+    // CVPixelBuffer is in any YUV format, multi-plane
+    GrYUVABackendTextures textures =
+        SkiaCVPixelBufferUtils::YUV::getSkiaTextureForCVPixelBuffer(
+            pixelBuffer);
+    return SkImages::TextureFromYUVATextures(context.skContext.get(), textures);
+  }
+  default:
+    [[unlikely]] {
+      throw std::runtime_error("Failed to convert PlatformBuffer to SkImage - "
+                               "PlatformBuffer has unsupported PixelFormat! " +
+                               std::to_string(static_cast<int>(format)));
+    }
   }
-  return SkImages::TextureFromImage(
-      ThreadContextHolder::ThreadSkiaMetalContext.skContext.get(), image);
 }
